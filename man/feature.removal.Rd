% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/feature_removal.R
\name{feature.removal}
\alias{feature.removal}
\title{Stepwise feature removal method}
\usage{
feature.removal(g1, g0, cutoff1, cutoff0, lt = ">", offset = 1,
  weight.method = reciprocal.colSums, scoreStandardization.method = min_max,
  scoreCombine.method = linear.combine)
}
\arguments{
\item{g1}{a dataframe with the row of feature, and the column of observation.
Cells are numeric or bool.}

\item{g0}{a dataframe with the same row names as \code{g1}. Normally, the observations
in \code{g0} are in the distinct group of \code{g1}.}

\item{cutoff1}{\code{g1} is converted to a dataframe filled with 1 or 0 by \code{cutoff1}
and \code{lt}. The result is called \code{g1.signal}. For example, if \code{lt=">"},
the result of the step is \code{g1.signal <- g1 > cutoff1}. If you do not want
the conversion, let \code{cutoff1} be \code{g1} dataframe, and \code{lt="<-"}.}

\item{cutoff0}{\code{g0} is converted to dataframes of 1 or 0 by \code{cutoff0} and \code{lt}. 
It has the same usage as \code{cutoff1}. Different \code{cutoff1} and \code{cutoff0} 
influence overfitting.}

\item{lt}{An operator to compare \code{gx} and \code{cutoffx}. Default is ">".
Other options include ">=", "<=", "<", etc.}

\item{offset}{a parameter in \code{scoreCombine.method}. It adjusts the score proportion
of g1 and g2. Besides, \code{offset} can be a number or a numeric vector.
If it is a vector, the overall iteration is done for each offset respectively.
See more in parameter \code{scoreCombine.method}.}

\item{weight.method}{\code{gx.weight}, weight of gx, is computed using
\code{weight.method}. The weight is for the observations/columns, not the
features/rows. The default weight method is \code{reciprocal.colSums}, ie.
\code{1 / (1 + colSums(gx.signal, na.rm=T))}. You can specify your own function,
and the first parameter of the function should be the exact word of \code{gx.signal}.}

\item{scoreStandardization.method}{Default standardization method is Min-Max,
ie. normalizing the vector to 0-1 range. You can specify your own function,
and the first parameter of the function is the sum-up dataframe. See more in
Details section.}

\item{scoreCombine.method}{to combine the feature score vectors of g1 and g0.
This method must have three parameters in order, \code{g1.score.feature},
\code{g0.score.feature}, and \code{offset}. Default method is \code{linear.combine}.
\code{offset} in the default method adjusts the proportion of \code{g1.score.feature}.
Specifically, \code{g1.score.feature * offset + g0.score.feature}. Besides,
\code{offset} can be a number or a vector. If it is a vector, the overall
iteration is done for each offset respectively.}

\item{...}{Other parameter passed to method of expression class.}
}
\value{
a list with names "offset", "removed.feature_names", "removed.scores",
and "max.scores".
}
\description{
This function screens features iteratively in consideration of
limiting overfitting and overall performance.
}
\details{
The method removes one feature/row in each iteration, and requires
two dataframes, \code{g1} and \code{g0}, with identical row names. Normally,
\code{g0} is the control set.\\
In each iteration, first, \code{g1} and \code{g0} are converted to dataframes
of 1 or 0 by \code{cutoff1}, \code{cutoff0}, and \code{lt}. The converted
dataframes are called \code{gx.singal}, and \code{x} stands for 1 and 0. If
you do not want the conversion, let the parameters \code{cutoff1=g1,
cutoff0=g0, lt="<-"}, or just use an alternative function
\code{iteremoval::multiple.feature.removal.iteration}.\\
Second, \code{gx.weight}, weight of gx, is computed using \code{weight.method}.
The weight is for the observations/columns, not the features/rows. The
default weight method is \code{reciprocal.colSums}, ie.
\code{1 / (1 + colSums(gx.signal, na.rm=T))}. You can specify your own
function, and the first parameter of the function should be the exact word of
\code{gx.signal}.\\
Third, \code{gx.score}, the score dataframe for observations and features, is
computed. It is the result of dot product of \code{gx.signal} and \code{gx.weight}.\\
Then, Summing up \code{gx.score} by row, and the result is standardized with
function \code{scoreStandardization.method}. Default standardization method is
Min-Max, ie. normalizing the vector to 0-1 range. You can specify your own
function, and the first parameter of the function is the sum-up dataframe.\\
After that, \code{gx.score.feature}, the feature scores of gx are calculated.
Now using \code{scoreCombine.method} to combine the feature score vectors of
g1 and g0. This method must have three parameters in order, \code{g1.score.feature},
\code{g0.score.feature}, and \code{offset}. Default method is \code{linear.combine}.
\code{offset} in the default method adjusts the proportion of \code{g1.score.feature}.
Specifically, \code{g1.score.feature * offset + g0.score.feature}. Besides,
\code{offset} can be a number or a vector. If it is a vector, the overall iteration
is done for each offset respectively.
}
\examples{

g1 = SWR1[,5:ncol(SWR1)]
g0 = SWR0[,5:ncol(SWR0)]

row.names(g1) <- SWR1[,4]
row.names(g0) <- SWR0[,4]

result.simple <- feature.removal(g1, g0, cutoff1=0.95, cutoff0=0.95)

result.complex <- feature.removal(g1, g0,
    cutoff1=0.95, cutoff0=0.925, lt=">",
    offset=c(0.5, 1, 2),
    weight.method="reciprocal.colSums",
    scoreStandardization.method="min_max",
    scoreCombine.method="linear.combine")

}
\seealso{
Other iteration: \code{\link{feature.removal.iteration}},
  \code{\link{multiple.feature.removal.iteration}}
}
\author{
Jiacheng CHUAN
}
